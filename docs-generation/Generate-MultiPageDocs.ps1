#!/usr/bin/env pwsh
<#
.SYNOPSIS
    Multi-page documentation generator for Azure MCP tools - simplified orchestration script
    
.DESCRIPTION
    This script runs the Azure MCP CLI to get tools data, then calls the C# generator
    to produce documentation using Handlebars templates.
    
.PARAMETER OutputPath
    Base output directory for generated files (relative to script location, default: ../generated)
    
.PARAMETER Format
    Output format for data files: 'json', 'yaml', or 'both' (default: both)
    
.PARAMETER CreateIndex
    Whether to create an index page (default: true)
    
.PARAMETER CreateCommon
    Whether to create a common tools page (default: true)
    
.PARAMETER CreateCommands
    Whether to create a commands page (default: true)
    
.PARAMETER CreateToolPages
    Whether to create per-service tool pages (default: false)

.PARAMETER CreateServiceOptions
    Whether to create a service start options page (default: true)
    
.PARAMETER ExamplePrompts
    Whether to generate example prompts using Azure OpenAI (default: false)
    
.EXAMPLE
    ./Generate-MultiPageDocs.ps1
    ./Generate-MultiPageDocs.ps1 -Format json
    ./Generate-MultiPageDocs.ps1 -CreateIndex $false
    ./Generate-MultiPageDocs.ps1 -CreateCommands $false
    ./Generate-MultiPageDocs.ps1 -CreateServiceOptions $false
    ./Generate-MultiPageDocs.ps1 -ExamplePrompts $true
#>

param(
    [string]$OutputPath = "../generated",
    [ValidateSet('json', 'yaml', 'both')]
    [string]$Format = 'json',
    [bool]$CreateIndex = $true,
    [bool]$CreateCommon = $true,
    [bool]$CreateCommands = $true,
    [bool]$CreateToolPages = $false,
    [bool]$CreateServiceOptions = $true,
    [bool]$ExamplePrompts = $true
)

# Resolve output path and set up logging
$currentDir = Get-Location
if ([System.IO.Path]::IsPathRooted($OutputPath)) {
    $outputDir = $OutputPath
} else {
    $outputDir = Join-Path $currentDir $OutputPath
}

# Normalize to absolute path (removes any .. segments)
$resolvedOutput = Resolve-Path $outputDir -ErrorAction SilentlyContinue
if ($resolvedOutput) {
    $outputDir = $resolvedOutput.ProviderPath
}

# Ensure output directory exists
if (-not (Test-Path $outputDir)) {
    New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
}

$logDir = Join-Path $outputDir "logs"
if (-not (Test-Path $logDir)) {
    New-Item -ItemType Directory -Path $logDir -Force | Out-Null
}
$logFile = Join-Path $logDir "generation-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
Start-Transcript -Path $logFile -Append
Write-Host "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] Log file: $logFile" -ForegroundColor Cyan

# Helper functions for colored output
function Write-Info { param([string]$Message) Write-Host "INFO: $Message" -ForegroundColor Cyan }
function Write-Success { param([string]$Message) Write-Host "SUCCESS: $Message" -ForegroundColor Green }
function Write-Warning { param([string]$Message) Write-Host "WARNING: $Message" -ForegroundColor Yellow }
function Write-Error { param([string]$Message) Write-Host "ERROR: $Message" -ForegroundColor Red }
function Write-Progress { param([string]$Message) Write-Host "PROGRESS: $Message" -ForegroundColor Magenta }

# Main execution
try {
    Write-Progress "Starting Azure MCP Multi-Page Documentation Generation..."
    
    # Debug: Show current working directory and output directory
    $currentDir = Get-Location
    Write-Info "Current working directory: $currentDir"
    Write-Info "Output directory: $outputDir"
    
    Write-Info "Using CLI files from: $outputDir/cli/"
    
    # Verify CLI files exist (should already be generated by start.sh or similar)
    $cliOutputFile = Join-Path $outputDir "cli/cli-output.json"
    $namespaceOutputFile = Join-Path $outputDir "cli/cli-namespace.json"
    $versionOutputFile = Join-Path $outputDir "cli/cli-version.json"
    
    # Debug: Show absolute paths being checked
    Write-Info "Checking for files:"
    Write-Info "  â€¢ $cliOutputFile"
    Write-Info "  â€¢ $namespaceOutputFile"
    Write-Info "  â€¢ $versionOutputFile"
    
    $cliExists = Test-Path $cliOutputFile
    $namespaceExists = Test-Path $namespaceOutputFile
    $versionExists = Test-Path $versionOutputFile
    
    Write-Info "File existence check:"
    Write-Info "  â€¢ cli-output.json: $cliExists"
    Write-Info "  â€¢ cli-namespace.json: $namespaceExists"
    Write-Info "  â€¢ cli-version.json: $versionExists"
    
    $filesExist = @($cliExists, $namespaceExists, $versionExists) | Measure-Object -Sum | Select-Object -ExpandProperty Sum
    
    if ($filesExist -ne 3) {
        Write-Error "CLI files are missing. Please run start.sh or equivalent to generate:"
        Write-Error "  â€¢ $cliOutputFile (exists: $cliExists)"
        Write-Error "  â€¢ $namespaceOutputFile (exists: $namespaceExists)"
        Write-Error "  â€¢ $versionOutputFile (exists: $versionExists)"
        throw "CLI files not found"
    }
    
    Write-Success "âœ“ CLI files verified"
    
    # Load version information
    Write-Info "Loading version information from: $versionOutputFile"
    $versionContent = Get-Content $versionOutputFile -Raw
    Write-Info "Version file content: '$versionContent'"
    
    # Check if it's JSON or plain text
    if ($versionContent.Trim().StartsWith('{')) {
        # JSON format
        $versionData = $versionContent | ConvertFrom-Json
        $cliVersion = $versionData.version
    } else {
        # Plain text format (just the version string)
        $cliVersion = $versionContent.Trim()
    }
    
    Write-Info "CLI Version: $cliVersion"
    
    # Generate annotations using separate script
    Write-Progress "Step 1: Generating annotation include files..."
    & "$PSScriptRoot\scripts\Generate-Annotations.ps1" -OutputPath $OutputPath -CliVersion $cliVersion
    if ($LASTEXITCODE -ne 0) {
        throw "Annotations generation failed"
    }

    # Generate parameters using separate script
    Write-Progress "Step 2: Generating parameter include files..."
    & "$PSScriptRoot\scripts\Generate-Parameters.ps1" -OutputPath $OutputPath -CliVersion $cliVersion
    if ($LASTEXITCODE -ne 0) {
        throw "Parameters generation failed"
    }

    # Generate commands using separate script
    if ($CreateCommands) {
        Write-Progress "Step 3: Generating commands page..."
        & "$PSScriptRoot\scripts\Generate-Commands.ps1" -OutputPath $OutputPath -CliVersion $cliVersion -CreateServiceOptions $CreateServiceOptions
        if ($LASTEXITCODE -ne 0) {
            throw "Commands generation failed"
        }
    }

    # Generate common using separate script
    if ($CreateCommon) {
        Write-Progress "Step 4: Generating common tools page..."
        & "$PSScriptRoot\scripts\Generate-Common.ps1" -OutputPath $OutputPath -CliVersion $cliVersion -CreateServiceOptions $CreateServiceOptions
        if ($LASTEXITCODE -ne 0) {
            throw "Common tools generation failed"
        }
    }

    # Generate index using separate script
    if ($CreateIndex) {
        Write-Progress "Step 5: Generating index page..."
        & "$PSScriptRoot\scripts\Generate-Index.ps1" -OutputPath $OutputPath -CliVersion $cliVersion -CreateServiceOptions $CreateServiceOptions
        if ($LASTEXITCODE -ne 0) {
            throw "Index generation failed"
        }
    }

    # Generate example prompts using separate script
    if ($ExamplePrompts) {
        Write-Progress "Step 6: Generating example prompts with Azure OpenAI..."
        & "$PSScriptRoot\scripts\Generate-ExamplePromptsAI.ps1" -OutputPath $OutputPath -CliVersion $cliVersion
        if ($LASTEXITCODE -ne 0) {
            throw "Example prompts generation failed"
        }
    }

    # Parse tool count information from CLI data instead
    Write-Info ""
    Write-Info "Parsing tool information from CLI data..."
    
    try {
        $cliData = Get-Content $cliOutputFile -Raw | ConvertFrom-Json
        $totalTools = if ($cliData.results) { $cliData.results.Count } else { 0 }
        
        # Group tools by area for statistics
        $toolCountsByArea = @{}
        if ($cliData.results) {
            foreach ($tool in $cliData.results) {
                $command = $tool.command ?? ""
                if ($command) {
                    $area = ($command -split ' ')[0]
                    if (-not $toolCountsByArea.ContainsKey($area)) {
                        $toolCountsByArea[$area] = 0
                    }
                    $toolCountsByArea[$area]++
                }
            }
        }
        
        $totalAreas = $toolCountsByArea.Count
        Write-Success "âœ“ Parsed tool information: $totalTools tools across $totalAreas areas"
    } catch {
        Write-Warning "Failed to parse CLI data for statistics: $($_.Exception.Message)"
        $totalTools = 0
        $totalAreas = 0
        $toolCountsByArea = @{}
    }
    
    # Step 7: Generate tool generation pipeline (complete tools, AI improvements, tool families)
    Write-Progress "Step 7: Tool Generation Pipeline"
    Write-Info ""
    & "$PSScriptRoot\scripts\Generate-ToolGeneration.ps1" -OutputPath $OutputPath
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Tool generation pipeline failed or was skipped"
    }
    Write-Info ""
    
    # Step 3.1: Generate tools.json using ToolDescriptionEvaluator and compare tool counts
    Write-Progress "Step 3.1: Generating tools.json for comparison..."
    
    $toolDescriptionEvaluatorScript = "..\eng\tools\ToolDescriptionEvaluator\Update-ToolsJson.ps1"
    $toolDescriptionEvaluatorPath = "..\eng\tools\ToolDescriptionEvaluator\tools.json"
    $localToolDescPath = Join-Path $outputDir "ToolDescriptionEvaluator.json"
    
    try {
        # Run the ToolDescriptionEvaluator script to generate tools.json if present
        if (Test-Path $toolDescriptionEvaluatorScript) {
            & $toolDescriptionEvaluatorScript -Force
            if ($LASTEXITCODE -ne 0) {
                Write-Warning "Failed to run ToolDescriptionEvaluator Update-ToolsJson.ps1, continuing with CLI-only comparison"
            } else {
                Write-Success "ToolDescriptionEvaluator tools.json generated successfully"
            
                # Copy the generated tools.json to our generated folder for easy access
                if (Test-Path $toolDescriptionEvaluatorPath) {
                    Copy-Item $toolDescriptionEvaluatorPath $localToolDescPath -Force
                    $localToolDescSize = [math]::Round((Get-Item $localToolDescPath).Length / 1KB, 1)
                    Write-Success "ToolDescriptionEvaluator output copied to: $localToolDescPath (${localToolDescSize}KB)"
                }
            
                # Compare tool counts between CLI output and ToolDescriptionEvaluator output
                Write-Progress "Comparing tool counts between CLI output and ToolDescriptionEvaluator..."
            
                try {
                    # Parse CLI output
                    $cliData = Get-Content $cliOutputFile -Raw | ConvertFrom-Json
                    $cliToolCount = if ($cliData.results) { $cliData.results.Count } else { 0 }
                
                    # Parse ToolDescriptionEvaluator output
                    $toolDescData = Get-Content $toolDescriptionEvaluatorPath -Raw | ConvertFrom-Json
                    $toolDescToolCount = if ($toolDescData.results) { $toolDescData.results.Count } else { 0 }
                
                    Write-Info ""
                    Write-Info "Tool Count Comparison:"
                    Write-Info "  ðŸ“Š CLI tool count: $cliToolCount"
                    Write-Info "  ðŸ“Š ToolDescriptionEvaluator tool count: $toolDescToolCount"
                
                    if ($cliToolCount -eq $toolDescToolCount) {
                        Write-Success "  âœ“ Tool counts match! Both sources report $cliToolCount tools."
                    } else {
                        Write-Warning "  âš  Tool count mismatch detected!"
                        Write-Warning "    CLI output: $cliToolCount tools"
                        Write-Warning "    ToolDescriptionEvaluator: $toolDescToolCount tools"
                        Write-Warning "    Difference: $([Math]::Abs($cliToolCount - $toolDescToolCount)) tools"
                    
                        # Identify missing tools
                        $cliToolNames = $cliData.results | ForEach-Object { "$($_.command)" } | Sort-Object
                        $toolDescToolNames = $toolDescData.results | ForEach-Object { "$($_.command)" } | Sort-Object
                    
                        $missingInToolDesc = $cliToolNames | Where-Object { $_ -notin $toolDescToolNames }
                        $missingInCli = $toolDescToolNames | Where-Object { $_ -notin $cliToolNames }
                    
                        if ($missingInToolDesc.Count -gt 0) {
                            Write-Warning ""
                            Write-Warning "  Tools present in CLI but missing in ToolDescriptionEvaluator:"
                            foreach ($tool in $missingInToolDesc) {
                                Write-Warning "    - $tool"
                            }
                        }
                    
                        if ($missingInCli.Count -gt 0) {
                            Write-Warning ""
                            Write-Warning "  Tools present in ToolDescriptionEvaluator but missing in CLI:"
                            foreach ($tool in $missingInCli) {
                                Write-Warning "    - $tool"
                            }
                        }
                    
                        # Save comparison report
                        $comparisonReport = @{
                            timestamp         = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                            cliToolCount      = $cliToolCount
                            toolDescToolCount = $toolDescToolCount
                            difference        = [Math]::Abs($cliToolCount - $toolDescToolCount)
                            missingInToolDesc = $missingInToolDesc
                            missingInCli      = $missingInCli
                        }
                    
                        $comparisonReportPath = Join-Path $outputDir "tool-count-comparison.json"
                        $comparisonReport | ConvertTo-Json -Depth 3 | Out-File -FilePath $comparisonReportPath -Encoding UTF8
                        Write-Info "    ðŸ“„ Tool count comparison report saved: $comparisonReportPath"
                    }
                
                } catch {
                    Write-Warning "Failed to compare tool counts: $($_.Exception.Message)"
                }
            }
        } else {
            Write-Info "ToolDescriptionEvaluator scripts not found. Skipping comparison step."
        }
    } catch {
        Write-Warning "Error running ToolDescriptionEvaluator: $($_.Exception.Message)"
    }
    
    Write-Success "Multi-page documentation generation completed successfully!"
    Write-Info ""
    Write-Info "Generated files in '$outputDir':"
    
    # List generated files using absolute path
    $actualOutputDir = $outputDir
    if (Test-Path $actualOutputDir) {
        $files = Get-ChildItem $actualOutputDir -Name "*.md" | Sort-Object
        foreach ($file in $files) {
            $filePath = Join-Path $actualOutputDir $file
            $sizeKB = [math]::Round((Get-Item $filePath).Length / 1KB, 1)
            Write-Info "  ðŸ“„ $file (${sizeKB}KB)"
        }
    }
    
    Write-Info ""
    Write-Info "Data files:"
    $actualCliOutputPath = Join-Path $outputDir "cli/cli-output.json"
    if (Test-Path $actualCliOutputPath) {
        $jsonSize = [math]::Round((Get-Item $actualCliOutputPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $actualCliOutputPath (${jsonSize}KB) - CLI output"
    }
    
    $actualNamespaceOutputPath = Join-Path $outputDir "cli/cli-namespace.json"
    if (Test-Path $actualNamespaceOutputPath) {
        $namespaceSize = [math]::Round((Get-Item $actualNamespaceOutputPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $actualNamespaceOutputPath (${namespaceSize}KB) - CLI namespace output"
    }
    
    $actualCsvOutputPath = Join-Path $outputDir "namespaces.csv"
    if (Test-Path $actualCsvOutputPath) {
        $csvSize = [math]::Round((Get-Item $actualCsvOutputPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $actualCsvOutputPath (${csvSize}KB) - Alphabetically sorted namespaces CSV"
    }
    
    $comparisonReportPath = Join-Path $outputDir "tool-count-comparison.json"
    if (Test-Path $comparisonReportPath) {
        $reportSize = [math]::Round((Get-Item $comparisonReportPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $comparisonReportPath (${reportSize}KB) - Tool count comparison report"
    }
    
    $toolDescOutputPath = "..\eng\tools\ToolDescriptionEvaluator\tools.json"
    if (Test-Path $toolDescOutputPath) {
        $toolDescSize = [math]::Round((Get-Item $toolDescOutputPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $toolDescOutputPath (${toolDescSize}KB) - ToolDescriptionEvaluator tools.json"
    }
    
    if (Test-Path $localToolDescPath) {
        $localToolDescSize = [math]::Round((Get-Item $localToolDescPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $localToolDescPath (${localToolDescSize}KB) - ToolDescriptionEvaluator tools.json (local copy)"
    }
    
    $totalPages = (Get-ChildItem $actualOutputDir -Name "*.md" | Measure-Object).Count
    Write-Success "Documentation generation complete: $totalPages pages created using C# generator with Handlebars templates"
    
    # Build comprehensive summary for file output
    $summaryLines = @()
    $summaryLines += "# Azure MCP Documentation Generation Summary"
    $summaryLines += ""
    $summaryLines += "**Generated:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
    $summaryLines += "**Generation Method:** C# generator with Handlebars templates"
    $summaryLines += "**Total Pages Created:** $totalPages"
    $summaryLines += ""
    
    # Generated files section
    $summaryLines += "## Generated Documentation Files"
    $summaryLines += ""
    if (Test-Path $actualOutputDir) {
        $files = Get-ChildItem $actualOutputDir -Name "*.md" | Sort-Object
        foreach ($file in $files) {
            $filePath = Join-Path $actualOutputDir $file
            $sizeKB = [math]::Round((Get-Item $filePath).Length / 1KB, 1)
            $summaryLines += "- ðŸ“„ $file (${sizeKB}KB)"
        }
    }
    
    # Data files section
    $summaryLines += ""
    $summaryLines += "## Data Files"
    $summaryLines += ""
    
    if (Test-Path $actualCliOutputPath) {
        $jsonSize = [math]::Round((Get-Item $actualCliOutputPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $actualCliOutputPath (${jsonSize}KB) - CLI output"
    }
    
    if (Test-Path $actualNamespaceOutputPath) {
        $namespaceSize = [math]::Round((Get-Item $actualNamespaceOutputPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $actualNamespaceOutputPath (${namespaceSize}KB) - CLI namespace output"
    }
    
    if (Test-Path $actualCsvOutputPath) {
        $csvSize = [math]::Round((Get-Item $actualCsvOutputPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $actualCsvOutputPath (${csvSize}KB) - Alphabetically sorted namespaces CSV"
    }
    
    if (Test-Path $comparisonReportPath) {
        $reportSize = [math]::Round((Get-Item $comparisonReportPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $comparisonReportPath (${reportSize}KB) - Tool count comparison report"
    }
    
    if (Test-Path $toolDescOutputPath) {
        $toolDescSize = [math]::Round((Get-Item $toolDescOutputPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $toolDescOutputPath (${toolDescSize}KB) - ToolDescriptionEvaluator tools.json"
    }
    
    # Display tool count statistics
    if ($totalTools -gt 0) {
        $summaryLines += ""
        $summaryLines += "## Tool Statistics"
        $summaryLines += ""
        $summaryLines += "- **Total tools:** $totalTools"
        $summaryLines += "- **Total service areas:** $totalAreas"
        
        if ($toolCountsByArea.Count -gt 0) {
            $summaryLines += ""
            $summaryLines += "### Tools by Service Area"
            $summaryLines += ""
            foreach ($area in ($toolCountsByArea.Keys | Sort-Object)) {
                $count = $toolCountsByArea[$area]
                $summaryLines += "- **${area}:** $count tools"
            }
        }
    }
    
    # Save summary to file
    $summaryFilePath = Join-Path $outputDir "generation-summary.md"
    try {
        $summaryContent = $summaryLines -join "`n"
        $summaryContent | Out-File -FilePath $summaryFilePath -Encoding UTF8
        $summaryFileSize = [math]::Round((Get-Item $summaryFilePath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $summaryFilePath (${summaryFileSize}KB) - Generation summary"
    } catch {
        Write-Warning "Failed to save generation summary to file: $($_.Exception.Message)"
    }
    
    Write-Success "Documentation generation complete: $totalPages pages created using C# generator with Handlebars templates"
    
    # Display console summary (detailed summary saved to generation-summary.md)
    if ($totalTools -gt 0) {
        Write-Info ""
        Write-Info "Tool Statistics:"
        Write-Info "  ðŸ“Š Total tools: $totalTools"
        Write-Info "  ðŸ“Š Total service areas: $totalAreas"
        
        if ($toolCountsByArea.Count -gt 0) {
            Write-Info "  ðŸ“Š Tools by service area:"
            foreach ($area in ($toolCountsByArea.Keys | Sort-Object)) {
                $count = $toolCountsByArea[$area]
                Write-Info "     â€¢ ${area}: $count tools"
            }
        }
    }

} catch {
    Write-Error "Documentation generation failed: $($_.Exception.Message)"
    Write-Error "Error details: $($_.ScriptStackTrace)"
    Stop-Transcript
    exit 1
}

Write-Host "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] Generation complete" -ForegroundColor Green
Stop-Transcript
