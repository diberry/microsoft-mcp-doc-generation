#!/usr/bin/env pwsh
<#
.SYNOPSIS
    Multi-page documentation generator for Azure MCP tools - simplified orchestration script
    
.DESCRIPTION
    This script runs the Azure MCP CLI to get tools data, then calls the C# generator
    to produce documentation using Handlebars templates.
    
.PARAMETER OutputPath
    Base output directory for generated files (relative to script location, default: ../generated)
    
.PARAMETER Format
    Output format for data files: 'json', 'yaml', or 'both' (default: both)
    
.PARAMETER CreateIndex
    Whether to create an index page (default: true)
    
.PARAMETER CreateCommon
    Whether to create a common tools page (default: true)
    
.PARAMETER CreateCommands
    Whether to create a commands page (default: true)
    
.PARAMETER CreateToolPages
    Whether to create per-service tool pages (default: false)

.PARAMETER CreateServiceOptions
    Whether to create a service start options page (default: true)
    
.PARAMETER ExamplePrompts
    Whether to generate example prompts using Azure OpenAI (default: false)
    
.EXAMPLE
    ./Generate.ps1
    ./Generate.ps1 -Format json
    ./Generate.ps1 -CreateIndex $false
    ./Generate.ps1 -CreateCommands $false
    ./Generate.ps1 -CreateServiceOptions $false

#>

param(
    [string]$OutputPath = "../../generated",
    [ValidateSet('json', 'yaml', 'both')]
    [string]$Format = 'json',
    [bool]$CreateIndex = $true,
    [bool]$CreateCommon = $true,
    [bool]$CreateCommands = $true,
    [bool]$CreateToolPages = $false,
    [bool]$CreateServiceOptions = $true
)

# Resolve output path and set up logging
$currentDir = Get-Location
if ([System.IO.Path]::IsPathRooted($OutputPath)) {
    $outputDir = $OutputPath
} else {
    $outputDir = Join-Path $currentDir $OutputPath
}

# Normalize to absolute path (removes any .. segments)
$resolvedOutput = Resolve-Path $outputDir -ErrorAction SilentlyContinue
if ($resolvedOutput) {
    $outputDir = $resolvedOutput.ProviderPath
}

# Ensure output directory exists
if (-not (Test-Path $outputDir)) {
    New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
}

$logDir = Join-Path $outputDir "logs"
if (-not (Test-Path $logDir)) {
    New-Item -ItemType Directory -Path $logDir -Force | Out-Null
}
$logFile = Join-Path $logDir "generation-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
Start-Transcript -Path $logFile -Append
Write-Host "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] Log file: $logFile" -ForegroundColor Cyan

# Helper functions for colored output
function Write-Info { param([string]$Message) Write-Host "INFO: $Message" -ForegroundColor Cyan }
function Write-Success { param([string]$Message) Write-Host "SUCCESS: $Message" -ForegroundColor Green }
function Write-Warning { param([string]$Message) Write-Host "WARNING: $Message" -ForegroundColor Yellow }
function Write-Error { param([string]$Message) Write-Host "ERROR: $Message" -ForegroundColor Red }
function Write-Progress { param([string]$Message) Write-Host "PROGRESS: $Message" -ForegroundColor Magenta }

# Main execution
try {
    Write-Progress "Starting Azure MCP Multi-Page Documentation Generation..."
    
    # Debug: Show current working directory and output directory
    $currentDir = Get-Location
    Write-Info "Current working directory: $currentDir"
    Write-Info "Output directory: $outputDir"
    
    Write-Info "Using CLI files from: $outputDir/cli/"
    
    # Verify CLI files exist (should already be generated by start.sh or similar)
    $cliOutputFile = Join-Path $outputDir "cli/cli-output.json"
    $namespaceOutputFile = Join-Path $outputDir "cli/cli-namespace.json"
    $versionOutputFile = Join-Path $outputDir "cli/cli-version.json"
    
    # Debug: Show absolute paths being checked
    Write-Info "Checking for files:"
    Write-Info "  â€¢ $cliOutputFile"
    Write-Info "  â€¢ $namespaceOutputFile"
    Write-Info "  â€¢ $versionOutputFile"
    
    $cliExists = Test-Path $cliOutputFile
    $namespaceExists = Test-Path $namespaceOutputFile
    $versionExists = Test-Path $versionOutputFile
    
    Write-Info "File existence check:"
    Write-Info "  â€¢ cli-output.json: $cliExists"
    Write-Info "  â€¢ cli-namespace.json: $namespaceExists"
    Write-Info "  â€¢ cli-version.json: $versionExists"
    
    $filesExist = @($cliExists, $namespaceExists, $versionExists) | Measure-Object -Sum | Select-Object -ExpandProperty Sum
    
    if ($filesExist -ne 3) {
        Write-Error "CLI files are missing. Please run start.sh or equivalent to generate:"
        Write-Error "  â€¢ $cliOutputFile (exists: $cliExists)"
        Write-Error "  â€¢ $namespaceOutputFile (exists: $namespaceExists)"
        Write-Error "  â€¢ $versionOutputFile (exists: $versionExists)"
        throw "CLI files not found"
    }
    
    Write-Success "âœ“ CLI files verified"
    
    # Load version information
    Write-Info "Loading version information from: $versionOutputFile"
    $versionContent = Get-Content $versionOutputFile -Raw
    Write-Info "Version file content: '$versionContent'"
    
    # Check if it's JSON or plain text
    if ($versionContent.Trim().StartsWith('{')) {
        # JSON format
        $versionData = $versionContent | ConvertFrom-Json
        $cliVersion = $versionData.version
    } else {
        # Plain text format (just the version string)
        $cliVersion = $versionContent.Trim()
    }
    
    Write-Info "CLI Version: $cliVersion"
    
    # Generate annotations, parameters, raw tools, commands, and common
    Write-Progress "Step 1: Generating annotations, parameters, raw tools, commands, and common..."
    & "$PSScriptRoot\1-Generate-AnnotationsParametersRaw.ps1" -OutputPath $OutputPath -CreateCommands $CreateCommands -CreateCommon $CreateCommon -CreateServiceOptions $CreateServiceOptions
    if ($LASTEXITCODE -ne 0) {
        throw "Annotations/parameters/raw tools/commands/common generation failed"
    }

    # Step 1.1: Run CLI analyzer for visual analysis
    Write-Progress "Step 8: Running CLI Analyzer..."
    Write-Info ""
    & "$PSScriptRoot\Invoke-CliAnalyzer.ps1" -OutputPath $OutputPath -HtmlOnly $true
    Write-Info ""

    # Generate example prompts and validate them
    if ($ExamplePrompts) {
        Write-Progress "Step 2: Generating example prompts with Azure OpenAI and validating required parameters..."
        & "$PSScriptRoot\3-Generate-ExamplePrompts.ps1" -OutputPath $OutputPath
        if ($LASTEXITCODE -ne 0) {
            throw "Example prompts generation or validation failed"
        }
    }

    # Generate index using separate script
    # if ($CreateIndex) {
    #     Write-Progress "Step 3: Generating index page..."
    #     & "$PSScriptRoot\scripts\Generate-Index.ps1" -OutputPath $OutputPath -CliVersion $cliVersion -CreateServiceOptions $CreateServiceOptions
    #     if ($LASTEXITCODE -ne 0) {
    #         throw "Index generation failed"
    #     }
    # }

    # Parse tool count information from CLI data instead
    # Write-Info ""
    # Write-Info "Parsing tool information from CLI data..."
    
    # try {
    #     $cliData = Get-Content $cliOutputFile -Raw | ConvertFrom-Json
    #     $totalTools = if ($cliData.results) { $cliData.results.Count } else { 0 }
        
    #     # Group tools by area for statistics
    #     $toolCountsByArea = @{}
    #     if ($cliData.results) {
    #         foreach ($tool in $cliData.results) {
    #             $command = $tool.command ?? ""
    #             if ($command) {
    #                 $area = ($command -split ' ')[0]
    #                 if (-not $toolCountsByArea.ContainsKey($area)) {
    #                     $toolCountsByArea[$area] = 0
    #                 }
    #                 $toolCountsByArea[$area]++
    #             }
    #         }
    #     }
        
    #     $totalAreas = $toolCountsByArea.Count
    #     Write-Success "âœ“ Parsed tool information: $totalTools tools across $totalAreas areas"
    # } catch {
    #     Write-Warning "Failed to parse CLI data for statistics: $($_.Exception.Message)"
    #     $totalTools = 0
    #     $totalAreas = 0
    #     $toolCountsByArea = @{}
    # }
    
    # Step 4: Generate tool family files (complete tools, AI improvements, tool families)
    Write-Progress "Step 4: Tool Family Generation Pipeline"
    Write-Info ""
    & "$PSScriptRoot\4-Generate-ToolFamilyFiles.ps1" -OutputPath $OutputPath
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Tool family generation pipeline failed or was skipped"
    }
    Write-Info ""
    
    # Step 5: Validate total tool counts and generate family reports
    Write-Progress "Step 5: Validating total tool counts and generating family reports..."
    Write-Info ""
    & "$PSScriptRoot\5-Validate-total-tool-count-and-family.ps1" -OutputPath $OutputPath
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Tool count validation completed with warnings"
    }
    Write-Info ""
    
    Write-Success "Multi-page documentation generation completed successfully!"
    Write-Info ""
    Write-Info "Generated files in '$outputDir':"
    
    # List generated files using absolute path
    $actualOutputDir = $outputDir
    if (Test-Path $actualOutputDir) {
        $files = Get-ChildItem $actualOutputDir -Name "*.md" | Sort-Object
        foreach ($file in $files) {
            $filePath = Join-Path $actualOutputDir $file
            $sizeKB = [math]::Round((Get-Item $filePath).Length / 1KB, 1)
            Write-Info "  ðŸ“„ $file (${sizeKB}KB)"
        }
    }
    
    Write-Info ""
    Write-Info "Data files:"
    $actualCliOutputPath = Join-Path $outputDir "cli/cli-output.json"
    if (Test-Path $actualCliOutputPath) {
        $jsonSize = [math]::Round((Get-Item $actualCliOutputPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $actualCliOutputPath (${jsonSize}KB) - CLI output"
    }
    
    $actualNamespaceOutputPath = Join-Path $outputDir "cli/cli-namespace.json"
    if (Test-Path $actualNamespaceOutputPath) {
        $namespaceSize = [math]::Round((Get-Item $actualNamespaceOutputPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $actualNamespaceOutputPath (${namespaceSize}KB) - CLI namespace output"
    }
    
    $actualCsvOutputPath = Join-Path $outputDir "namespaces.csv"
    if (Test-Path $actualCsvOutputPath) {
        $csvSize = [math]::Round((Get-Item $actualCsvOutputPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $actualCsvOutputPath (${csvSize}KB) - Alphabetically sorted namespaces CSV"
    }
    
    $comparisonReportPath = Join-Path $outputDir "tool-count-comparison.json"
    if (Test-Path $comparisonReportPath) {
        $reportSize = [math]::Round((Get-Item $comparisonReportPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $comparisonReportPath (${reportSize}KB) - Tool count comparison report"
    }
    
    $toolDescOutputPath = "..\eng\tools\ToolDescriptionEvaluator\tools.json"
    if (Test-Path $toolDescOutputPath) {
        $toolDescSize = [math]::Round((Get-Item $toolDescOutputPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $toolDescOutputPath (${toolDescSize}KB) - ToolDescriptionEvaluator tools.json"
    }
    
    if (Test-Path $localToolDescPath) {
        $localToolDescSize = [math]::Round((Get-Item $localToolDescPath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $localToolDescPath (${localToolDescSize}KB) - ToolDescriptionEvaluator tools.json (local copy)"
    }
    
    $totalPages = (Get-ChildItem $actualOutputDir -Name "*.md" | Measure-Object).Count
    Write-Success "Documentation generation complete: $totalPages pages created using C# generator with Handlebars templates"
    
    # Build comprehensive summary for file output
    $summaryLines = @()
    $summaryLines += "# Azure MCP Documentation Generation Summary"
    $summaryLines += ""
    $summaryLines += "**Generated:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
    $summaryLines += "**Generation Method:** C# generator with Handlebars templates"
    $summaryLines += "**Total Pages Created:** $totalPages"
    $summaryLines += ""
    
    # Generated files section
    $summaryLines += "## Generated Documentation Files"
    $summaryLines += ""
    if (Test-Path $actualOutputDir) {
        $files = Get-ChildItem $actualOutputDir -Name "*.md" | Sort-Object
        foreach ($file in $files) {
            $filePath = Join-Path $actualOutputDir $file
            $sizeKB = [math]::Round((Get-Item $filePath).Length / 1KB, 1)
            $summaryLines += "- ðŸ“„ $file (${sizeKB}KB)"
        }
    }
    
    # Data files section
    $summaryLines += ""
    $summaryLines += "## Data Files"
    $summaryLines += ""
    
    if (Test-Path $actualCliOutputPath) {
        $jsonSize = [math]::Round((Get-Item $actualCliOutputPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $actualCliOutputPath (${jsonSize}KB) - CLI output"
    }
    
    if (Test-Path $actualNamespaceOutputPath) {
        $namespaceSize = [math]::Round((Get-Item $actualNamespaceOutputPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $actualNamespaceOutputPath (${namespaceSize}KB) - CLI namespace output"
    }
    
    if (Test-Path $actualCsvOutputPath) {
        $csvSize = [math]::Round((Get-Item $actualCsvOutputPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $actualCsvOutputPath (${csvSize}KB) - Alphabetically sorted namespaces CSV"
    }
    
    if (Test-Path $comparisonReportPath) {
        $reportSize = [math]::Round((Get-Item $comparisonReportPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $comparisonReportPath (${reportSize}KB) - Tool count comparison report"
    }
    
    if (Test-Path $toolDescOutputPath) {
        $toolDescSize = [math]::Round((Get-Item $toolDescOutputPath).Length / 1KB, 1)
        $summaryLines += "- ðŸ“„ $toolDescOutputPath (${toolDescSize}KB) - ToolDescriptionEvaluator tools.json"
    }
    
    # Display tool count statistics
    if ($totalTools -gt 0) {
        $summaryLines += ""
        $summaryLines += "## Tool Statistics"
        $summaryLines += ""
        $summaryLines += "- **Total tools:** $totalTools"
        $summaryLines += "- **Total service areas:** $totalAreas"
        
        if ($toolCountsByArea.Count -gt 0) {
            $summaryLines += ""
            $summaryLines += "### Tools by Service Area"
            $summaryLines += ""
            foreach ($area in ($toolCountsByArea.Keys | Sort-Object)) {
                $count = $toolCountsByArea[$area]
                $summaryLines += "- **${area}:** $count tools"
            }
        }
    }
    
    # Save summary to file
    $summaryFilePath = Join-Path $outputDir "generation-summary.md"
    try {
        $summaryContent = $summaryLines -join "`n"
        $summaryContent | Out-File -FilePath $summaryFilePath -Encoding UTF8
        $summaryFileSize = [math]::Round((Get-Item $summaryFilePath).Length / 1KB, 1)
        Write-Info "  ðŸ“„ $summaryFilePath (${summaryFileSize}KB) - Generation summary"
    } catch {
        Write-Warning "Failed to save generation summary to file: $($_.Exception.Message)"
    }
    
    Write-Success "Documentation generation complete: $totalPages pages created using C# generator with Handlebars templates"
    
    # Display console summary (detailed summary saved to generation-summary.md)
    if ($totalTools -gt 0) {
        Write-Info ""
        Write-Info "Tool Statistics:"
        Write-Info "  ðŸ“Š Total tools: $totalTools"
        Write-Info "  ðŸ“Š Total service areas: $totalAreas"
        
        if ($toolCountsByArea.Count -gt 0) {
            Write-Info "  ðŸ“Š Tools by service area:"
            foreach ($area in ($toolCountsByArea.Keys | Sort-Object)) {
                $count = $toolCountsByArea[$area]
                Write-Info "     â€¢ ${area}: $count tools"
            }
        }
    }
    
    # Step 7: Run validation orchestrator
    Write-Progress "Step 7: Running Validation Checks..."
    Write-Info ""
    & "$PSScriptRoot\Validate.ps1" -OutputPath $OutputPath
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Validation checks reported issues"
    }
    Write-Info ""



} catch {
    Write-Error "Documentation generation failed: $($_.Exception.Message)"
    Write-Error "Error details: $($_.ScriptStackTrace)"
    Stop-Transcript
    exit 1
}

Write-Host "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] Generation complete" -ForegroundColor Green
Stop-Transcript
